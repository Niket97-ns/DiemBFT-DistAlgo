# type: ignore
import replica

import nacl.utils
from nacl.signing import SigningKey
import random
import time
import util


class Client(process):
    def setup(privateKey, clientPublicKeyMap, replicaPublicKeyMap, f=0, number_of_requests=4, seed=2, t=25):
        self.f = f      # Maximum Byzantine Fault Tolerance
        self.privateKey = privateKey
        self.clientPublicKeyMap = clientPublicKeyMap
        self.replicaPublicKeyMap = replicaPublicKeyMap
        # Number of requests the client has
        self.number_of_requests = number_of_requests
        self.t = t

        random.seed(seed)
        # Initial delay after which client sends request
        self.delay = set_initial_delay()
        self.responseMap = {}
        self.request_number = 1    # Initial request number
        # self.sequence_number = 1    # Sequence number to uniquely identify request
        self.committed_requests = set()  # Check for requests already committed
        self.main = main
    # def receive(msg=("Reply",M), from_=r):
    #     output("got stuff")

    def run():

        while self.request_number <= self.number_of_requests:
            time.sleep(self.delay)
            self.delay = set_initial_delay()
            request = str(self)+"-"+str(request_number)
            encoded_request = str.encode(request)
            digest, msg_to_send = util.createDigest(encoded_request)
            # TODO: use another variable to store validators
            send(('Request', request, msg_to_send, digest),
                 to=self.replicaPublicKeyMap.keys())
            # if await(some(received(('Reply',_)))):

            if await(len(setof(r, received(('Reply', _), from_=r))) > self.f + 1):
                self.request_number += 1
                output("Receved at client side ***********")
                reset(received)
            elif timeout(6):
                output("timed out, sending again.")
        send(('done',), to=parent())

    def set_initial_delay():
        return random.randint(0, 1)//100

    def generate_request():
        return request

    def receive(msg=("ResponseHandler", (response, response_digest, request_number,)), from_=c):

        if request_number in self.responseMap:
            if response_digest in self.responseMap[request_number]:
                self.responseMap[request_number][response_digest] += 1
            else:
                self.responseMap[request_number][response_digest] = 1
        else:
            self.responseMap[request_number] = {}
            self.responseMap[request_number][response_digest] = 1

        # If the request number of the response has not already been committed
        if request_number not in self.committed_requests:

            if self.responseMap[request_number][response_digest] >= (self.f + 1):
                self.committed_requests.add(request_number)
                self.request_number += 1
                if self.request_number <= self.number_of_requests:
                    # TODO: Send next request to all replicas
                    time.sleep(self.delay)
                    self.delay = set_initial_delay()
                    request = str(self)+"-"+str(request_number)
                    send(('Request', request,),
                         to=self.replicaPublicKeyMap.keys())

# type: ignore

import vote_info as vi
from ledger_commit_info import LedgerCommitInfo
from util import valid_signatures, createDigest, createConcatString
from vote_msg import VoteMsg
import block_tree as bt
from timeoutInfo import TimeOutInfo
import pickle
# import safet


class Safety():

    def __init__(self, author, ledger, blockTree, private_key, public_keys, highest_vote_round=0, highest_qc_round=-1):

        self.author = author
        self.ledger = ledger
        self.blockTree = blockTree
        # private key of replica using the safety object.
        self.private_key = private_key
        self.public_keys = public_keys
        self.highest_vote_round = highest_vote_round
        self.highest_qc_round = highest_qc_round

    def __increase_highest_vote_round(self, round):
        self.highest_vote_round = max(self.highest_vote_round, round)

    def __update_highest_qc_round(self, qc_round):
        self.highest_qc_round = max(self.highest_qc_round, qc_round)

    def __consecutive(self, block_round, round):
        '''
        Checks if round is followed by block_round
        '''

        return round+1 == block_round

    def __safe_to_extend(self, block_round, qc_round, tc):
        return self.__consecutive(block_round, tc.round) and qc_round >= max(tc.tmo_high_qc_rounds)

    def __safe_to_vote(self, block_round, qc_round, tc):

        if block_round <= max(self.highest_vote_round, qc_round):
            # 1. Must vote in monotonically increasing rounds AND
            # 2. Must extend a smaller round.
            return False
        # Extending qc round from previous round or safe to extend due to tc
        return self.__consecutive(block_round, qc_round) or self.__safe_to_extend(block_round, qc_round, tc)

    def __safe_to_timeout(self, round, qc_round, tc):
        if qc_round < self.highest_qc_round or round <= max(self.highest_vote_round-1, qc_round):
            # Respect highest_qc_round and don't timeout in a past round
            return False

        # qc or tc must allow entering the round to timeout
        return self.__consecutive(round, qc_round) or self.__consecutive(round, tc.round)

    def __commit_state_id_candidate(self, block_round, qc):
        # Find the committed id in case a qc is formed in a vote round
        if self.__consecutive(block_round, qc.vote_info.round):
            return (self.ledger.pending_state(qc.vote_info.id))
            pass
        else:
            return None

    def make_vote(self, b, last_tc):
        qc_round = b.qc.vote_info.round

        # TODO: Develop valid signature function
        if valid_signatures(b, last_tc) and self.__safe_to_vote(b.round, qc_round, last_tc):
            self.__update_highest_qc_round(qc_round)    # Protect qc round
            # Don't vote again in this or lower round
            self.__increase_highest_vote_round(b.round)

            # VoteInfo carries the potential QC info with ids and rounds of the parent QC
            # TODO: Ledger object creation
            vote_info = vi.VoteInfo(
                b.id, b.round, b.qc.vote_info.id, qc_round, self.ledger.pending_state(b.id))
            # TODO:
            digest_of_vote_info = createDigest(
                createConcatString(b.id, b.round, b.qc.vote_info.id, qc_round, self.ledger.pending_state(b.id)))[0]

            ledger_commit_info = LedgerCommitInfo(
                digest_of_vote_info, self.__commit_state_id_candidate(b.round, b.qc))
            return VoteMsg(self.author, vote_info, ledger_commit_info, self.blockTree.high_commit_qc, self.private_key)

        return None

    def make_timeout(self, author, privateKey, round, high_qc, last_tc):
        qc_round = high_qc.vote_info.round
        # TODO: Develop valid signature function
        if valid_signatures(high_qc, last_tc) and self.__safe_to_timeout(round, qc_round, last_tc):
            self.__increase_highest_vote_round(round)  # stop voting for round
            # TODO: Develop Timeout Info
            return TimeOutInfo(author, privateKey, round, high_qc)
        return None

    def sign(self, *args):
        a = tuple(args)
        return self.private_key.sign(pickle.dumps(a))

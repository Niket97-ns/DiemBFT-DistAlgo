# type: ignore

from block_tree import BlockTree
from ledger import Ledger
from safety import Safety


class time_outs_senders:
    def __init__(self) -> None:
        pass
        # self.senders = {sender_name : signature}


class Pacemaker:
    def __init__(self):
        self.current_round = 0
        self.last_round_tc = None
        self.f = 1
        self.pending_timeouts = {}
        # self.round_time = 300

    def stop_timer(self, round):
        pass

    def get_round_timer(self, round):

        # TODO: need to understand this formula for round_timer
        # return round_time(round)
        return self.round_time

    def start_timer(self, new_round):
        self.stop_timer(self.current_round)
        self.current_round = new_round
        # start local timer for round current_round for duration get_round_timer(current_round)

    def local_timeout_round(self, new_round):
        # TODO: need to do something about the timer
        stop_timer(self.current_round)

        self.current_round = new_round

        # TODO: need to do something about the timer
        start_time(self.get_round_timer(self.current_round))

    def local_timeout_round(self):
        # TODO: for now according to my understanding
        Ledger.save_consensus_state()

        timeout_info = Safety.time_out(
            timeout_info, last_round, _tc, Block_tree.high_qc, self.last_round_tc)

        # TODO: Not sure what is called here
        # broadcast TimeoutMsg(timeout_info, self.last_round_tc, BlockTree.high_commit_qc)

    def process_remote(self, tmo):
        tmo_info = tmo.tmo_info
        if tmo_info.round < self.current_round:
            return None

        if tmo_info.round not in self.pending_timeouts:
            self.pending_timeouts[tmo_info.round] = {senders: set()}

        if tmo_info.sender not in self.pending_timeouts[tmo_info.round].senders:
            self.pending_timeouts[tmo_info.round].add(tmo_info.sender)

        if len(self.pending_timeouts[tmo_info.round].senders) == self.f + 1:
            stop_time(self.current_round)
            self.local_timeout_round()

        if len(self.pending_timeouts[tmo_info.round].senders) == 2 * self.f + 1:
            t = self.pending_timeouts[tmo_info.round].pop()
            return TC(tmo_info.round, t.high_qc_rounds, signature(t.signatures))

        return None

    def advance_round_tc(self, tc):
        if tc == None or tc.high_qc_rounds < self.current_round:
            return False

        self.last_round_tc = tc
        self.start_timer(tc.round + 1)
        return True

    def advance_round_qc(self, qc):
        if qc.vote_info.round < self.current_round:
            return False

        self.last_round_tc = None
        self.start_timer(qc.vote_info.round + 1)
        # return True

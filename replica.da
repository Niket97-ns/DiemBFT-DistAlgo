# type: ignore
import pickle
import nacl.utils
from nacl.signing import SigningKey
from nacl.signing import VerifyKey
from pprint import pprint
from block_tree import BlockTree
from safety import Safety
from mempool import Mempool
from tc import TC
from vote_info import VoteInfo
from ledger_commit_info import LedgerCommitInfo
from qc import QC
from ledger import Ledger
import random
from timeoutMsg import TimeoutMsg
from tc import TC
import time
import util
import os


class ProposalMsg:
    def __init__(self, block, last_tc, high_commit_qc, safety):
        self.block = block
        self.last_tc = last_tc
        self.high_commit_qc = high_commit_qc
        self.signature = safety.sign(self.block.id)
        


class Replica(process):

    def setup(privateKey, clientPublicKeyMap, replicaPublicKeyMap, f, t, config):
        self.testingFlag = True
        self.config = config
        self.doneFlag = False
        self.privateKey = privateKey
        self.clientPublicKeyMap = clientPublicKeyMap
        self.replicaPublicKeyMap = replicaPublicKeyMap
        self.proposalMsgFlag = False
        if not os.path.isdir(config['test_case']):
            os.mkdir(config['test_case'])

        # ---------- start leaderElection -------- #
        self.validators = list(replicaPublicKeyMap.keys())
        self.window_size = 4
        self.exclude_size = 1
        self.reputation_leaders = {}
        # ---------- end leaderElection -------- #

        self.commit_cache = {}
        self.f = f

        self.last_tc = TC(0, [0]*(2*(self.f)+1), [None]*(2*(self.f)+1))

        # ------------- Initialize ledger object -------- #
        self.mempool = Mempool()
        # -------------- End ledger initialization ------ #

        # ------------- Initialize ledger object -------- #
        self.ledger = Ledger(self, self.mempool, config['test_case'])
        # -------------- End ledger initialization ------ #

        # --------------- Initialize block tree ---------- #
        self.blockTree = BlockTree(
            author=self, f=self.f, ledger=self.ledger)
        # --------------- End Initializing block tree ---------- #

        # -------------- start pacemaker attribute initialization ------------ #
        self.pacemaker_current_round = 1
        self.pacemaker_pending_timeouts = {}
        self.pacemaker_last_round_tc = TC(
            0, [0]*(2*(self.f)+1), [None]*(2*(self.f)+1))
        self.pacemaker_local_time = 5
        # -------------- end pacemaker attribute initialization -------------- #

        # -------------- initialize safety module ----------------------- #
        self.safety = Safety(
            self, self.ledger, self.blockTree, self.privateKey, self.replicaPublicKeyMap)
        # -------------- end safety module initialization --------------- #

        # self.start = time.time()
        # self.max_time = -1
        self.one_round_time_timeout = 4 * 0.07

    #################################################################
    ############## Fault Injection part #############

    def setattr(attr, val):
        # we can't implement setattr using reflection, because the distalgo compiler
        # needs to transform the assignment statements.
        # if the updated attribute is in another class (e.g., Pacemaker), modify the
        # assignment statement accordingly.
        if attr == 'current_round':
            self.pacemaker_current_round = val
        elif attr == 'last_vote_round':
            last_vote_round = val
        else:
            output('error: Replica.setattr: unsupported attribute')

    #################################################################
    ############## Start Pacemaker Function Definitions #############

    def Pacemaker_stop_timer(round):
        pass

    def Pacemaker_get_round_timer(round):
        random.seed(round)
        return random.randint(0, 8)
        # TODO: need to understand this formula for round_timer
        # return round_time(round)

    def Pacemaker_start_timer(new_round):
        self.proposalMsgFlag = True
        self.Pacemaker_stop_timer(self.pacemaker_current_round)
        self.pacemaker_current_round = new_round
        self.Pacemaker_local_time = Pacemaker_get_round_timer(
            self.pacemaker_current_round)

    def Pacemaker_local_timeout_round():

        timeoutInfo = self.safety.make_timeout(
            self, self.privateKey, self.pacemaker_current_round, self.blockTree.high_qc, self.pacemaker_last_round_tc)
        timeout_msg = TimeoutMsg(
            timeoutInfo, self.pacemaker_last_round_tc, self.blockTree.high_commit_qc)
        signed_timeout_msg = self.safety.sign(timeout_msg)

        
        output("About to send timeout message for round ", self.pacemaker_current_round)

        send(("process_timeout_message", signed_timeout_msg), to=self.validators)

    def Pacemaker_process_remote_timeout(tmo):
        tmo_info = tmo.tmo_info

        if tmo_info.round < self.pacemaker_current_round:
            return None
        # if tmo_info.sender()
        if tmo_info.round not in self.pacemaker_pending_timeouts:

            self.pacemaker_pending_timeouts[tmo_info.round] = set()
            self.pacemaker_pending_timeouts[tmo_info.round].add(tmo_info)

        else:
            # Check if senders tmo_info is already present
            # If not, insert
            present = False
            for i in self.pacemaker_pending_timeouts[tmo_info.round]:
                if i.sender == tmo_info.sender:
                    present = True
            if not present:
                self.pacemaker_pending_timeouts[tmo_info.round].add(tmo_info)
        if len(self.pacemaker_pending_timeouts[tmo_info.round]) == self.f + 1:
            Pacemaker_local_timeout_round()
        if len(self.pacemaker_pending_timeouts[tmo_info.round]) == 2*self.f + 1:
            tmo_high_qc_rounds_list = []
            tmo_signatures_list = []
            for t in self.pacemaker_pending_timeouts[tmo_info.round]:
                tmo_high_qc_rounds_list.append(t.high_qc.vote_info.round)
                # tuple of sender and sign
                tmo_signatures_list.append((t.sender, t.signature))

            return TC(tmo_info.round, tmo_high_qc_rounds_list, tmo_signatures_list)

    def Pacemaker_advance_round_tc(tc):
        if tc == None or tc.round < self.pacemaker_current_round:
            return False

        self.pacemaker_last_round_tc = tc
        # self.last_tc = tc
        # self.last_round_tc = tc
        self.Pacemaker_start_timer(tc.round + 1)
        return True

    def Pacemaker_advance_round_qc(qc):
        if qc.vote_info.round < self.pacemaker_current_round:
            return False

        self.pacemaker_last_round_tc = None
        # self.last_tc = None
        # self.last_round_tc = None
        self.Pacemaker_start_timer(qc.vote_info.round + 1)
        # return True

        # tmo_info = tmo.tmo_info
        # if tmo_info.round < self.pacemaker_current_round:
        #     return None
        # if tmo_info.sender not in pending_timeouts[tmo_info.round].senders:
        #     # pending_timeouts[tmo_info.round]
        #     len(pending_timeouts[tmo_info.round].senders) == self.f+1

    #################################################################
    ############## End Pacemaker Function Definitions #############

    #################################################################
    ############## Start LeaderElection Function Definitions #############

    def Leader_elect_reputation_leader(qc):
        active_validators = set()
        last_authors = set()
        current_qc = qc
        i = 0
        while i < self.window_size or len(last_authors) < self.exclude_size:
            if current_qc.vote_info.parent_id not in self.ledger.committed_ledger_tree.block_id_to_state:
                break
            else:

                # TODO: Different than paper
                current_block_id = current_qc.vote_info.parent_id
                current_block = self.blockTree.pending_block_tree.get_block(
                    current_block_id)
                if current_block is None:
                    break
                block_author = current_block.author
                if i < self.window_size:
                    # TODO: add signers
                    active_validators = active_validators.union(
                        current_qc.signers)
                if len(last_authors) < self.exclude_size:
                    last_authors.add(block_author)

                current_qc = current_block.qc
            i += 1
        active_validators = active_validators.difference(last_authors)
        if len(active_validators) == 0:
            return Leader_get_round_robin_leader(qc.vote_info.round + 2)

        else:
            random.seed(qc.vote_info.round)
            temp = random.sample(active_validators, 1)
            return temp[0]

    # def Leader_pick_one(active_validators, seed):

    def Leader_get_round_robin_leader(curr_round):
        # Round robin leader (2 rounds per leader)
        idx = (curr_round) % len(self.validators)
        return self.validators[idx]

    def Leader_get_leader(round):
        # TODO: IDK

        if round in self.reputation_leaders:
            return self.reputation_leaders[round]

        return self.Leader_get_round_robin_leader(round)

    def Leader_update_leaders(qc):
        extended_round = qc.vote_info.parent_round
        qc_round = qc.vote_info.round
        pacemaker_current_round = self.pacemaker_current_round
        if extended_round + 1 == qc_round and qc_round + 1 == pacemaker_current_round:
            # TODO: Check paper
            # self.leader = Leader_get_round_robin_leader(
            #     pacemaker_current_round + 1)
            # pass
            self.reputation_leaders[pacemaker_current_round +
                                    1] = Leader_elect_reputation_leader(qc)

            # self.reputation_leaders[pacemaker_current_round +
            #                         1] = election_reputation_leader(qc)

    #################################################################
    ############## End LeaderElection Function Definitions #############

    def process_certificate_qc(qc):
        wasCommitted, client = self.blockTree.process_qc(qc)

        if wasCommitted and client is not None and client != "":
            send(('Reply', self), to=client)

        self.Leader_update_leaders(qc)
        # TODO: Check paper : Code invalid
        self.Pacemaker_advance_round_qc(qc)

    def process_new_round_event(last_tc):
        # Not sure what they are trying to check
        # TODO: Check code, change to get_leader and self.pacemaker.curr_round
        if self == self.Leader_get_leader(self.pacemaker_current_round):
            output("I am leader of round", self.pacemaker_current_round)
            next_transaction = self.mempool.get_requested_transaction()
            output("My proposed transaction", next_transaction)
            if next_transaction is None:
                # TODO: Return till timeout
                b = self.blockTree.generate_block(self,
                                                  self.pacemaker_current_round, ("", ""))
                # TODO: Handle this
                new_proposal = ProposalMsg(
                    b, last_tc, self.blockTree.high_commit_qc, self.safety)
                signed_proposal = self.safety.sign(new_proposal)
                send(("process_proposal_message", signed_proposal),
                     to=self.validators)
                pass
            else:
                b = self.blockTree.generate_block(self,
                                                  self.pacemaker_current_round, next_transaction)
                # TODO: Handle this
                new_proposal = ProposalMsg(
                    b, last_tc, self.blockTree.high_commit_qc, self.safety)
                signed_proposal = self.safety.sign(new_proposal)
                send(("process_proposal_message", signed_proposal),
                     to=self.validators)

    # I am confused if this is the same vote handler
    # because the sequence of these proceders in the papaer is different

    def receive(msg=("process_vote_msg", V), from_=c):
        verifyKeySender = VerifyKey(self.replicaPublicKeyMap[c])
        try:
            verifyKeySender.verify(V.message, V.signature)
            V = pickle.loads(V.message)
            V = V[0]
            qc, wasCommittedFlag, client = self.blockTree.process_vote(V)
            if wasCommittedFlag and client is not None and client != "":

                send(('Reply', self), to=client)

            if qc != None:
                self.process_certificate_qc(qc)
                # self.max_time = max(self.max_time, time.time() - self.start)
                # print("@@@@@@@@@@@@@@@@@ ",self.max_time," @@@@@@@@@@@@@@@@")
                # self.start = time.time()
                self.process_new_round_event(None)
        except:
            pass     

    def receive(msg=("process_proposal_message", P), from_=r):
        verifyKeySender = VerifyKey(self.replicaPublicKeyMap[r])
        try:
            verifyKeySender.verify(P.message, P.signature)
            P = pickle.loads(P.message)
            P = P[0]
            self.process_certificate_qc(P.block.qc)
            self.process_certificate_qc(P.high_commit_qc)

            self.Pacemaker_advance_round_tc(P.last_tc)
            round = self.pacemaker_current_round
            # it should be round but name converntions was a bit weird
            temp_leader = self.Leader_get_leader(round)
            # need to confirm the data type of leader variable
            # output(P.block.payload)

            # TODO: SYNC Up
            send(("Sync_me", "I am behind"),
                 to=self.validators)

            if P.block.round != round or r != temp_leader or P.block.author != temp_leader or (P.block.payload != ('', '') and P.block.payload not in self.mempool.q):
                if P.block.round > round:
                    pass
                return None

            self.blockTree.execute_and_insert(P.block)

            vote_msg = self.safety.make_vote(P.block, P.last_tc)
            if vote_msg != None:
                # need to find receive handler for this send
                new_leader_name = self.Leader_get_leader(round + 1)
                # need to decide the message
                if P.block.payload != ("", ""):
                    self.mempool.make_transaction_pending(P.block.payload)

                signed_vote_msg = self.safety.sign(vote_msg)
                send(("process_vote_msg", signed_vote_msg), to=new_leader_name)
        except:
            pass

    def receive(msg=("Sync me", "I am behind"), from_=r):
        output("Received sync request from a replica ,", r)

    def receive(msg=("process_timeout_message", T), from_=c):
        verifyKeySender = VerifyKey(self.replicaPublicKeyMap[c])
        try:
            verifyKeySender.verify(T.message, T.signature)
            T = pickle.loads(T.message)
            T = T[0]
            self.process_certificate_qc(T.tmo_info.high_qc)
            self.process_certificate_qc(T.high_commit_qc)
            self.Pacemaker_advance_round_tc(T.last_round_tc)
            tc = self.Pacemaker_process_remote_timeout(T)
            if tc != None:
                output("TC generated for round ", self.pacemaker_current_round)
                self.Pacemaker_advance_round_tc(tc)
                self.process_new_round_event(tc)
        except:
            pass

    # receive handler for client requests
    def receive(msg=('Request', request, message_to_hash, digest), from_=c):
        request_tuple = (request, c)
        if util.checkDigest(message_to_hash, digest):
            if request_tuple in self.ledger.commit_cache:
                send(('Reply', self), to=c)
                return
            self.mempool.addTxns(request_tuple)
        return

    def receive(msg=('done', "Done")):
        self.doneFlag = True

    def run():
        process_new_round_event(self.last_tc)
        while True:
            if await(self.doneFlag and self.mempool.allCommitted()):
                break
            elif await(self.proposalMsgFlag):
                self.proposalMsgFlag = False
            elif timeout(self.one_round_time_timeout):
                Pacemaker_local_timeout_round()
        output("Replica closing")
        exit()


class ReplicaFI(process, Replica):
    # override send method
    def setup(privateKey, clientPublicKeyMap, replicaPublicKeyMap, f, t, config):
        super().setup(privateKey, clientPublicKeyMap, replicaPublicKeyMap, f, t, config)
        self.exitFlag = False
        # print("In setup")

    
    def send(M, to):
        super().send(M, to)
        # do original send
        # imagine that attr and val were obtained from a misbehavior spec.
        if M[0] == "process_proposal_message":
            if config['test_case'] == 'leader_crashed':
                print("leader crashing")
                self.exitFlag =  True
                
            elif config['test_case'] == 'leader_delayed':
                time.sleep(3)
            # attr = "current_round"
            # val = 3
            # setattr(attr, val)
        if M[0] == "process_vote_msg":
            if config['test_case'] == 'crashed_while_voting':
                print("Exited from here!!!!!!!!!!!!!!!!!!!!!!")
                self.exitFlag =  True

    def receive(msg=('done', "Done")):
        self.doneFlag = True

    def run():
        process_new_round_event(self.last_tc)
        while True:
            if await(self.exitFlag):
                print("***************REached the end*************")
                exit()
            elif await(self.doneFlag and self.mempool.allCommitted()):
                break
            elif await(self.proposalMsgFlag):
                self.proposalMsgFlag = False
            
            
            elif timeout(self.one_round_time_timeout):
                Pacemaker_local_timeout_round()
        # print("----------")
        

# type: ignore
import nacl.utils
from nacl.signing import SigningKey
from nacl.signing import VerifyKey
from pprint import pprint
from block_tree import BlockTree
from safety import Safety
from mempool import Mempool
from tc import TC
from vote_info import VoteInfo
from ledger_commit_info import LedgerCommitInfo
from qc import QC
from ledger import Ledger
import random


class ProposalMsg:
    def __init__(self, block, last_tc, high_commit_qc):
        self.block = block
        self.last_tc = last_tc
        self.high_commit_qc = high_commit_qc


class Replica(process):
    def setup(privateKey, clientPublicKeyMap, replicaPublicKeyMap, f, t=25):
        self.privateKey = privateKey
        self.clientPublicKeyMap = clientPublicKeyMap
        self.replicaPublicKeyMap = replicaPublicKeyMap
        self.flag = False
        # TODO: Temp self.leader
        self.leader = None
        # ---------- start leaderElection -------- #
        self.validators = list(replicaPublicKeyMap.keys())
        self.window_size = 4
        self.exclude_size = 1
        self.reputation_leaders = {}
        # ---------- end leaderElection -------- #

        # self.replicaPublicKeyMap.pop(self)
        self.commit_cache = {}
        self.f = f
        self.last_tc = TC(0, [0]*(2*(self.f)+1), [None]*(2*(self.f)+1))

        self.t = t
        # ------------- Initialize ledger object -------- #
        self.mempool = Mempool()
        # -------------- End ledger initialization ------ #
        # ------------- Initialize ledger object -------- #
        self.ledger = Ledger(self, self.mempool)
        # -------------- End ledger initialization ------ #

        # ------------- vote info ---------------- #
        # ------------- default values --------------- #
        self.vote_info = VoteInfo()

        # ------------- ledger commit info -------- #
        # ------------- default values --------------- #
        self.ledger_commit_info = LedgerCommitInfo(vote_info=self.vote_info)

        # ------------- block tree --------------- #
        # ------------- default values --------------- #
        self.high_qc = QC(vote_info=self.vote_info,
                          ledger_commit_info=self.ledger_commit_info)
        self.high_commit_qc = QC(
            vote_info=self.vote_info, ledger_commit_info=self.ledger_commit_info)

        self.blockTree = BlockTree(self,
                                   self.high_qc, self.high_commit_qc, self.f, self.ledger)

        # -------------- start pacemaker attribute initialization ------------ #

        self.pacemaker_current_round = 1
        self.pacemaker_pending_timeouts = {}
        self.pacemaker_last_round_tc = 1

        # -------------- end pacemaker attribute initialization -------------- #

        # -------------- initialize safety module ----------------------- #
        self.safety = Safety(
            self, self.ledger, self.blockTree, self.privateKey, self.replicaPublicKeyMap)
        # -------------- end safety module initialization --------------- #

        # self.safety = Safety()

    # def receive(msg=("PrepareHandler1",   ), from_=c):
    #     print("reached PreareHandler1")
    #     # print(digest.message, digest.signature)
    #     # output("received message prepare from client ", c)
    #     verify_key = VerifyKey(self.clientPublicKeyMap[c])
    #     # print(self, " am verifying from client ", c,
    #     #       verify_key.verify(digest))
    #     # forged = digest[:-1] + bytes([int(digest[-1]) ^ 1])
    #     # print(verify_key.verify(forged))

    #     send(("Prepared1",), to=c)

    # def receive(msg=("PrepareHandler2",  digest), from_=c):
    #     print("reached PreareHandler2")
    #     # print(digest.message, digest.signature)
    #     # output("received message prepare from client ", c)
    #     verify_key = VerifyKey(self.clientPublicKeyMap[c])
    #     # print(self, " am verifying from client ", c,
    #     #       verify_key.verify(digest))
    #     # forged = digest[:-1] + bytes([int(digest[-1]) ^ 1])
    #     # print(verify_key.verify(forged))

    #     send(("Prepared2",), to=c)

    # def receive(msg=("process_certificate_qc", qc), from_=c):
    #     print("*****************", qc)
    #     self.blockTree.process_qc(qc)
    #     self.leaderElection.update_leaders(qc)
    #     self.paceMaker.advance_round(qc.vote_info.round)

    #################################################################
    ############## Start Pacemaker Function Definitions #############

    def Pacemaker_stop_timer(round):
        pass

    def Pacemaker_get_round_timer(round):

        # TODO: need to understand this formula for round_timer
        # return round_time(round)
        pass
        # return self.round_time

    def Pacemaker_start_timer(new_round):
        self.Pacemaker_stop_timer(self.pacemaker_current_round)
        self.pacemaker_current_round = new_round

    def Pacemaker_advance_round_tc(tc):
        if tc == None or tc.round < self.pacemaker_current_round:
            return False

        self.pacemaker_last_round_tc = tc
        self.Pacemaker_start_timer(tc.round + 1)
        return True

    def Pacemaker_advance_round_qc(qc):
        if qc.vote_info.round < self.pacemaker_current_round:
            return False

        self.pacemaker_last_round_tc = None
        self.Pacemaker_start_timer(qc.vote_info.round + 1)
        # return True

    #################################################################
    ############## End Pacemaker Function Definitions #############

    #################################################################
    ############## Start LeaderElection Function Definitions #############

    def Leader_elect_reputation_leader(qc):
        active_validators = set()
        last_authors = set()
        current_qc = qc
        i = 0
        while i < self.window_size or len(last_authors) < self.exclude_size:
            # current_block = self.ledger.committed_ledger_tree[]
            # print(type(current_qc.vote_info.parent_id))
            if current_qc.vote_info.parent_id not in self.ledger.committed_ledger_tree.block_id_to_state:
                break
            else:

                # TODO: Different than paper
                current_block_id = current_qc.vote_info.parent_id
                current_block = self.blockTree.pending_block_tree.get_block(current_block_id)
                if current_block is None:
                    break
                block_author = current_block.author
                if i < self.window_size:
                    # TODO: add signers
                    active_validators = active_validators.union(current_qc.signers)
                if len(last_authors) < self.exclude_size:
                    last_authors.add(block_author)
                
                current_qc = current_block.qc
            i += 1
        active_validators = active_validators.difference(last_authors)
        if len(active_validators) == 0:
            # print("************")
            return Leader_get_round_robin_leader(qc.vote_info.round + 2)

        else:
            random.seed(qc.vote_info.round)
            temp = random.sample(active_validators,1)
            
            # print("!!!!!!!!!!!", temp)
            return temp[0]
            # return random.choice(active_validators)
            # return x

    # def Leader_pick_one(active_validators, seed):


    def Leader_get_round_robin_leader(curr_round):
        # Round robin leader (2 rounds per leader)
        idx = (curr_round) % len(self.validators)
        return self.validators[idx]

    def Leader_get_leader(round):
        # TODO: IDK
        # output("Getting leader for round",round)

        if round in self.reputation_leaders:
            # output("Getting by reputation for round",round)
            # output(round,"round, ",self.reputation_leaders)
            # print(self.reputation_leaders[round])
            # output(self.reputation_leaders[round])
            return self.reputation_leaders[round]
        # output("Getting by round robin for round",round)

        return self.Leader_get_round_robin_leader(round)

    def Leader_update_leaders(qc):
        extended_round = qc.vote_info.parent_round
        qc_round = qc.vote_info.round
        pacemaker_current_round = self.pacemaker_current_round
        if extended_round + 1 == qc_round and qc_round + 1 == pacemaker_current_round:
            # TODO: Check paper
            # self.leader = Leader_get_round_robin_leader(
            #     pacemaker_current_round + 1)
            # pass
            self.reputation_leaders[pacemaker_current_round+1] = Leader_elect_reputation_leader(qc)
        

            # self.reputation_leaders[pacemaker_current_round +
            #                         1] = election_reputation_leader(qc)

    #################################################################
    ############## End LeaderElection Function Definitions #############

    def process_certificate_qc(qc):
        self.blockTree.process_qc(qc)
        self.Leader_update_leaders(qc)
        # TODO: Check paper : Code invalid
        self.Pacemaker_advance_round_qc(qc)

    def process_new_round_event(last_tc):
        # Not sure what they are trying to check
        # TODO: Check code, change to get_leader and self.pacemaker.curr_round
        if self == self.Leader_get_leader(self.pacemaker_current_round):
            output("I am the leader of round", self.pacemaker_current_round)
            # output("My queue ", self.mempool.q)
            # output(" -----------  ", self, " am the leader.")
            # Create proposal Look into it again
            # print(self.mempool.get_transactions())
            next_transaction = self.mempool.get_requested_transaction()
            output("My proposed transaction", next_transaction)
            if next_transaction is None:
                # TODO: Return till timeout
                b = self.blockTree.generate_block(self,
                                                  self.pacemaker_current_round, "")
                # TODO: Handle this
                send(("process_proposal_message", ProposalMsg(b, self.last_tc, self.blockTree.high_commit_qc)),
                     to=self.validators)
                pass
            else:
                b = self.blockTree.generate_block(self,
                                                  self.pacemaker_current_round, next_transaction)
                # TODO: Handle this
                send(("process_proposal_message", ProposalMsg(b, self.last_tc, self.blockTree.high_commit_qc)),
                     to=self.validators)

    # I am confused if this is the same vote handler
    # because the sequence of these proceders in the papaer is different

    def receive(msg=("process_vote_msg", V), from_=c):
        qc = self.blockTree.process_vote(V)
        if qc != None:
            self.process_certificate_qc(qc)
            self.process_new_round_event(None)

    def receive(msg=("process_proposal_message", P), from_=r):
        # output("inside receive handler")
        # pprint(vars(P))
        self.process_certificate_qc(P.block.qc)
        self.process_certificate_qc(P.high_commit_qc)

        self.Pacemaker_advance_round_tc(P.last_tc)
        round = self.pacemaker_current_round
        # it should be round but name converntions was a bit weird
        self.leader = self.Leader_get_leader(round)
        # need to confirm the data type of leader variable

        if P.block.round != round or r != leader or P.block.author != leader:
            return None

        self.blockTree.execute_and_insert(P.block)

        vote_msg = self.safety.make_vote(P.block, P.last_tc)
        if vote_msg != None:
            # need to find receive handler for this send
            new_leader_name = self.Leader_get_leader(round + 1)
            # need to decide the message
            self.mempool.make_transaction_pending(P.block.payload)
            send(("process_vote_msg", vote_msg), to=new_leader_name)

    def receive(msg=("process_timeout_message", M), from_=c):
        self.process_certificate_qc(M.tmo_info.high_qc)
        self.process_certificate_qc(M.high_commit_qc)
        self.Pacemaker_advance_round_tc(M.last_round_tc)
        tc = self.Pacemaker_process_remote_timeout(M)
        if tc != None:
            self.Pacemaker_advance_round(tc)
            self.process_new_round_event(tc)

    # receive handler for client requests
    def receive(msg=('Request', request), from_=c):
        # output("Received ", request, "from ", c)
        if request in self.commit_cache:

            # TODO:Send previous response to client
            return

        self.mempool.addTxns(request)
        # print(self.mempool.q)
        # if not self.flag and self.Leader_get_leader(self.pacemaker_current_round) == self:
        # self.flag = True
        # process_new_round_event(self.last_tc)

        return

    def run():

        # await(some(received(("process_vote_msg", M),)))
        # await(some(received(("process_proposal_message", M),)))
        # await(some(received(("process_timeout_message", M),)))
        # await(some(received(("Request", request),)))
        if self == self.Leader_get_leader(self.pacemaker_current_round):
            await(not self.mempool.isEmpty())
            process_new_round_event(self.last_tc)
            await(False)
        else:
            await(self.pacemaker_current_round > 100)

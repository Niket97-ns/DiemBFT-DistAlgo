# type: ignore
from block import Block
from qc import QC
import defaultdict
# from block_tree_node import PendingBlockTree, BlockTreeNode
from ledger import Ledger


class PendingBlockTree:

    def __init__(self) -> None:
        self.id_to_block = {}  # Map: id - block

    def __init__(self) -> None:
        self.root = None
        self.current_leaf = None

    def __fork_and_add(self, block):
        # abandon current_leaf
        self.id_to_block.pop(self.current_leaf)
        # add new block to map
        self.id_to_block[block.id] = block
        # assign self.current_leaf to this block
        self.current_leaf = block
        # can the parennt block for the new block be different than self.current_leaf?
        # if yes then what to do?

    def add(self, block):
        self.id_to_block[block.id] = block
        # simple case without forking
        # should we verify that the qc.vote_info.id == self.current_leaf.id?
        self.current_leaf = block
        # since block already has qc, which already has block_id of parent
        # is there any other specific pointer to the parent even needed?
        # the map should take care of it imo

    def prune(self, parent_id):
        # this parent_id will be the new root
        # abandon all values in the tree that dont belong to the branch
        # from self.current_leaf to root
        # then make parent_id the new root
        blocks_in_curr_branch = []
        blocks_in_curr_branch.append(self.current_leaf.id)
        blocks_in_curr_branch.append(self.current_leaf.get_parent_id())
        blocks_in_curr_branch.append(parent_id)

        for block_id in self.id_to_block:
            if block_id not in blocks_in_curr_branch:
                del self.id_to_block[block_id]

        self.root = self.id_to_block[parent_id]

    def get_block(self, block_id):
        return self.id_to_block[block_id]


class BlockTree:

    def __init__(self, high_qc, high_commit_qc, f) -> None:
        self.high_qc = high_qc
        self.high_commit_qc = high_commit_qc
        self.f = f
        # TODO: need to create a tree structure somehow
        self.pending_block_tree = PendingBlockTree()

        # TODO: dictonary for now
        self.pending_votes = defaultdict()

    def process_qc(self):
        if qc.ledger_commit_info.commit_state_id != None:
            Ledger.commit(qc.vote_info.parent_id)
            # parent becomes new root we remove the committed message from the ppending tree
            pending_block_tree.prune(qc.vote_info.parent_id)

            # still a bit doubtful
            if qc.vote_info.round > self.high_commit_qc.vote_info.round:
                self.high_commit_qc = qc
        if qc.vote_info.round > self.high_qc.vote_info_round:
            self.high_qc = qc

    def execute_and_insert(block):
        Ledger.speculate(block.qc.vote_info.id, block.id, block.payload)
        self.pending_block_tree.add(block)

    def process_votes(self):
        self.process_qc(v.high_commit_qc)
        vote_idx = hash(v.ledger_commit_info)
        self.pending_votes[vote_idx] = self.pending_votes[vote_idx].add(
            v.signature)
        if len(self.pending_votes[vote_idx]) == 2 * self.f + 1:

            # Alert NOT sure about exe_state_id
            qc = QC(v.vote_info, v.vote_info.exec_state_id)

            return qc

    def generate_block(self, txns, curr_round):
        return Block(curr_round, txns, self.high_qc)
